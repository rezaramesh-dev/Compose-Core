üì¶ Core Network ‚Äì Reusable Android Networking Library

A modular, reusable, and production-ready network layer for Android projects built with:
	‚Ä¢	‚úÖ Hilt (Dependency Injection)
	‚Ä¢	‚úÖ Retrofit
	‚Ä¢	‚úÖ OkHttp
	‚Ä¢	‚úÖ Multi-binding Interceptors
	‚Ä¢	‚úÖ Optional Signature Interceptor
	‚Ä¢	‚úÖ Environment-based Base URL
	‚Ä¢	‚úÖ Debug-only Logging
	‚Ä¢	‚úÖ Fully Configurable & Extensible

Designed for medium to large-scale Android projects using MVVM and Jetpack Compose.

üöÄ Features

‚úî Clean & Reusable Architecture

No hard dependency on BuildConfig or app-specific values.

‚úî Optional Signature Interceptor

Projects can enable or disable request signing without modifying the core.

‚úî Multi-binding Interceptor Support

Any project can inject additional interceptors (Logging, Auth, Headers, etc.).

‚úî Debug-only Logging

Logging level is controlled by the consuming project.

‚úî Environment-aware Base URL

Supports Dev / Stage / Prod configurations.

‚úî Publish-ready

Designed to be distributed via JitPack or Maven.
----------------------------------------------------------------------------------------------------
üì• Installation

Add JitPack repository:

dependencyResolutionManagement {
    repositories {
        maven { url = uri("https://jitpack.io") }
    }
}

Add dependency:

implementation(com.github.rezaramesh-dev.Compose-Core:core-network:version)

----------------------------------------------------------------------------------------------------

üõ† Usage

1Ô∏è‚É£ Provide Base URL (Required)

In your app module:

@Module
@InstallIn(SingletonComponent::class)
object AppNetworkConfigModule {

    @Provides
    @Singleton
    fun provideBaseUrl(): String = BuildConfig.BASE_URL
}

2Ô∏è‚É£ Optional: Enable Signature Interceptor

If your API requires request signing:
@Module
@InstallIn(SingletonComponent::class)
object AppSignatureModule {

    @Provides
    @Singleton
    fun provideSignatureConfig(): SignatureConfig =
        object : SignatureConfig {
            override val apiKey = BuildConfig.API_KEY
            override val hmacKey = BuildConfig.HMAC_KEY
        }
}
If you don‚Äôt provide this, signature will be automatically disabled.

3Ô∏è‚É£ Optional: Add Logging Interceptor (Debug Only)

@Module
@InstallIn(SingletonComponent::class)
object AppInterceptorsModule {

    @Provides
    @Singleton
    @IntoSet
    fun provideLoggingInterceptor(): Interceptor =
        HttpLoggingInterceptor().apply {
            level = if (BuildConfig.DEBUG)
                HttpLoggingInterceptor.Level.BODY
            else
                HttpLoggingInterceptor.Level.NONE
        }
}

4Ô∏è‚É£ Optional: Add Custom Headers

class HeadersInterceptor(
    private val headers: Map<String, String>
) : Interceptor {

    override fun intercept(chain: Interceptor.Chain): Response {
        val builder = chain.request().newBuilder()

        headers.forEach { (key, value) ->
            builder.addHeader(key, value)
        }

        return chain.proceed(builder.build())
    }
}

Provide it:

@Provides
@IntoSet
fun provideHeadersInterceptor(): Interceptor =
    HeadersInterceptor(
        mapOf(
            "X-App-Version" to BuildConfig.VERSION_NAME,
            "X-Platform" to "Android"
        )
    )

5Ô∏è‚É£*Optional: Add Auth Token Interceptor*

class AuthInterceptor @Inject constructor(
    private val tokenProvider: TokenProvider
) : Interceptor {

    override fun intercept(chain: Interceptor.Chain): Response {
        val token = tokenProvider.getToken()

        val request = chain.request().newBuilder()

        token?.let {
            request.addHeader("Authorization", "Bearer $it")
        }

        return chain.proceed(request.build())
    }
}

@Binds
@IntoSet
abstract fun bindAuthInterceptor(
    interceptor: AuthInterceptor
): Interceptor

6Ô∏è‚É£Optional: Provide RetryConfig

@Module
@InstallIn(SingletonComponent::class)
object AppRetryModule {

    @Provides
    @Singleton
    fun provideRetryConfig(): RetryConfig =
        object : RetryConfig {
            override val maxRetry: Int = 3
            override val retryDelayMillis: Long = 1000L
        }
}
----------------------------------------------------------------------------------------------------

üì¶ Core Security ‚Äì Integration Guide for App Module

This guide explains how to integrate core-security into your consumer app.

core-security provides the encryption tools, keystore management, and security utilities. Your app module is responsible for actual storage implementation and dependency injection

2Ô∏è‚É£ Provide DataStore (or any storage backend)

SecureDataStoreStorage requires a DataStore instance:

@Module
@InstallIn(SingletonComponent::class)
object AppStorageModule {

    @Provides
    @Singleton
    fun provideDataStore(
        @ApplicationContext context: Context
    ): DataStore<Preferences> {

        return PreferenceDataStoreFactory.create(
            produceFile = { context.preferencesDataStoreFile("secure_prefs") }
        )
    }
}

You can replace DataStore with EncryptedSharedPreferences or any other secure storage.


3Ô∏è‚É£ Implement SecureStorage

Create a class that implements the SecureStorage interface from core-security:

class SecureDataStoreStorage @Inject constructor(
    private val dataStore: DataStore<Preferences>,
    private val encryptionManager: EncryptionManager
) : SecureStorage {

    override suspend fun save(key: String, value: String) {
        dataStore.edit {
            it[stringPreferencesKey(key)] = encryptionManager.encrypt(value)
        }
    }

    override suspend fun get(key: String): String? {
        val prefs = dataStore.data.first()
        val encrypted = prefs[stringPreferencesKey(key)] ?: return null
        return encryptionManager.decrypt(encrypted)
    }

    override suspend fun remove(key: String) {
        dataStore.edit {
            it.remove(stringPreferencesKey(key))
        }
    }

    override suspend fun clear() {
        dataStore.edit { it.clear() }
    }
}

4Ô∏è‚É£ Bind SecureStorage in Hilt

@Module
@InstallIn(SingletonComponent::class)
abstract class SecureStorageBindingModule {

    @Binds
    @Singleton
    abstract fun bindSecureStorage(
        impl: SecureDataStoreStorage
    ): SecureStorage
}

This allows any class in your app to inject SecureStorage:

class AuthRepository @Inject constructor(
    private val secureStorage: SecureStorage
) {

    suspend fun saveToken(token: String) {
        secureStorage.save("access_token", token)
    }

    suspend fun getToken(): String? {
        return secureStorage.get("access_token")
    }
}

6Ô∏è‚É£ Optional: Token Encryption & Storage
Use EncryptionManager for encrypting tokens, API keys, or any sensitive data:

val encryptedToken = encryptionManager.encrypt("my_token")
secureStorage.save("access_token", encryptedToken)

Decrypt when needed:

val token = secureStorage.get("access_token")?.let { encryptionManager.decrypt(it) }










































































core-network
	‚Ä¢	Retrofit builder
	‚Ä¢	OkHttp config
	‚Ä¢	Logging interceptor
	‚Ä¢	NetworkResult
	‚Ä¢	BaseApiResponse

core-database
	‚Ä¢	BaseDatabase
	‚Ä¢	Migration helper
	‚Ä¢	TypeConverters

core-datastore
	‚Ä¢	BaseDataStore
	‚Ä¢	SessionManager

core-ui
	‚Ä¢	BaseScaffold
	‚Ä¢	LoadingComponent
	‚Ä¢	ErrorView
	‚Ä¢	Theme
	‚Ä¢	Extensions

core-common
	‚Ä¢	DispatcherProvider
	‚Ä¢	BaseViewModel
	‚Ä¢	Result wrapper
	‚Ä¢	Extensions

	com.github.rezaramesh-dev.Compose-Core:core-security:0.0.2
    com.github.rezaramesh-dev.Compose-Core:core-common:0.0.2
    com.github.rezaramesh-dev.Compose-Core:core-network:0.0.2
    com.github.rezaramesh-dev.Compose-Core:core-ui:0.0.2